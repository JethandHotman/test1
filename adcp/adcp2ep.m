
function epDataFile = adcp2ep(adcpFile, epDataFile, ADCPtype, dlgFile, settings)

% ADCP2EP is used to translate RDI ADCP data into earth coordinates 
% and create an epic compatible data file.
% If the data is in Beam coordinates it will be transformed by runbm2g.m into
% Earth coordinates.  This transformation can be run on workhorse and broad
% band data, but the ADCP type must be specified.
%
% Magnetic Declination
%		If a magnetic declination was provided to the insturment prior to
%	deployment or to rdi2cdf in post-processing it will be applied at this
%	time for both Earth and Beam coordinat data
%
%function epDataFile = adcp2ep(adcpFile, epDataFile, ADCPtype, dlgFile, settings)
%Inputs:
%	adcpFile = the ADcp data file in beam coordinates
%		(Note:if running routines in sequence it should be the trimFile.)
%	epDataFile = the new Epic compatable file that will be created
%	ADCPtype = WH or BB; will default to WH if not specified
%		WH = workhorse, BB = broad band
%		note: if BB, do not need a dlgFile
%	dlgFile = the dialog file that was created when the ADCP was "deployed"
%   settings = a structure with the metadata inputs
%
%     settings.epDataFile = '8351wh.nc'; % final output file name
%     settings.experiment = 'Monterey Canyon 2007'; % your metadata
%     settings.project = 'MC2007'; % your metadata
%     settings.descript = 'Downward Facing Workhorse in MSC Sand wave field'; % your metadata, station or site number, for example
%     settings.SciPi = 'JPX'; % your metadata, principal investigator
%     settings.cmnt = 'barnacles were found on the transducers';  % your metadata
%     settings.water_mass = ' '; % an EPIC requirement
%     settings.long = 121.827229; % always positive degrees
%     settings.lonUnits = 'degrees_west';
%     settings.latit = 36.790360; % always positive degrees
%     settings.latUnits = 'degrees_north';
%     %the dialog file for your ADCP, there is one in the Demo directory.
%     %the toolbox use the instrument elevation and azimuth specific to each ADCP
%     settings.dlgFile = 'junk.dlg'; % generated by the ADCP using the PS3 command
%     settings.ADCPtype = 'WH'; % workhorse or BB for broadband

%	Note: If the names of the files are not given, they will be requested.
%
% Output:
%	epDataFile = same as input


%%% START USGS BOILERPLATE -------------%
% Use of this program is described in:
%
% Acoustic Doppler Current Profiler Data Processing System Manual 
% Jessica M. C�t�, Frances A. Hotchkiss, Marinna Martini, Charles R. Denham
% Revisions by: Andr�e L. Ramsey, Stephen Ruane
% U.S. Geological Survey Open File Report 00-458 
% Check for later versions of this Open-File, it is a living document.
%
% Program written in Matlab v7.1.0 SP3
% Program updated in Matlab 7.2.0.232 (R2006a)
% Program ran on PC with Windows XP Professional OS.
%
% "Although this program has been used by the USGS, no warranty, 
% expressed or implied, is made by the USGS or the United States 
% Government as to the accuracy and functioning of the program 
% and related program material nor shall the fact of distribution 
% constitute any such warranty, and no responsibility is assumed 
% by the USGS in connection therewith."
%
%%% END USGS BOILERPLATE --------------

% Written by Jessica M. Cote
% for the U.S. Geological Survey
% Coastal and Marine Geology Program
% Woods Hole, MA
% http://woodshole.er.usgs.gov/
% Please report bugs to jcote@usgs.gov

% Updated 09-jul-2008 (MM) bindist and depths still funny!
% Updated 18-jun-2008 (MM) change to SVN revision info
% Updated 25-feb-2008 (MM) heading bias was being divided by 100.  Don't know why.
% add the EPIC convention ORIGIN and convention to global atts
% Updated 20-feb-2008 (MM) abort gracefully if no input file found
% Updated 27-sep-2007 (EM) retain Hdg, Ptch, roll variables in ep file
%   and keep depth attribute: center_first_bin
% Updated 10-sep-2007 (MM) Remove FillValue from dimension variables time,
% time2, depth, lat, lon
% version 1.2
% Updated 12-feb-2007 (MM) improve how rotations are handled
% Updated 31-jan-07 (MM) remove batch calls
% Updated 29-jan-07 (MM) tread Pgd for INST and SHIP same as EARTH.
% Updated 26-jan-07 (MM) update mins and maxes
% Updated 25-jan-07 (MM) clarify height
% Updated 22-jan-2007 (MM) don't write pressure if the ADCP has no pressure sensor
% Updated 16-jan-07 (MM) add SciPi, Conventions, inst_depth & inst_height meta attributes
% Updated 24-dec-2006 (MM) allow inputs to be provided as a struct
% version 1.1
%   updated 12-sep=05 (SDR) changed the method in which metadata is
%               collected by the user to a more friendly manner
%   fixed 01-sep-05 (SDR) valid range attribute for velocity data so that
%                   it is now [-1000 1000] as it was formally [1000 1000]
%   updated 12-aug-2005 (SDR) removed fill_value definition in time and
%               time2 EPIC dimensions
%   fixed 30-Apr- 2003 depth calculation for down but no pressure sensor
%   updated 9-Apr-2003  depth calculations to use prssure sensor if available and able to calculate downward looking
%   added note to pressure variable
%   updated so runbm2g history comment will be added to epic file history attributes
%   updated latitude variable so same as longitude variable
%
% updated 19-March-2003 (ALR) added pressure variable
% updated 10-Jan-2003 (ALR) added ';' to stop data stream...
% updated 06-aug-2002 (ALR) Added OCSD to Experiment and LA Shelf ADCP to Description
% updated 01-Jul-2002 (ALR) time conversion won't crash on very short files (line 143)
% updated 29-Apr-2002 (ALR) fixed time stamp error; when moving time stamp to middle of ens, need to add instead of subtract
%       (line 132 corrected)

% version 1.0
% updated 03-Jul-2001 fixed spelling of Buoy (ALR)
% updated 28-Jun-2001 will now work with Matlab 6.0, r.12; problem was with getinfo.m for latitude and
%       longitude values line 428 to 433. (ALR)
% updated 28-Dec-2000 added linefeeds to history/comment attribute (ALR)
% updated 20-Oct-2000 so when computing data in EARTH coordinates the fill values
%		remain the same even after the data is corrected for magnetic declination. ALR
% updated 05-Oct-2000 added additional experiment names and locations.  A. Ramsey
% updated 03-Aug-2000 so creation date will include time.  Fran Hotchkiss
% updated 15-Mar-2000 08:49:03,
%		fixed Pgd and AGC corruption
% updated 02-Feb-2000 09:34:12,
%		fixed temperature weirdness and added rotation for earth data
% updated 16-Dec-1999 12:10:41, put in some clears to help memory
% updated 10-Dec-1999 10:52:22, modified to handel BB
% updated 29-Oct-1999 09:20:26
% updated 19-Oct-1999 13:43:47

% get the current SVN version- the value is automatically obtained in svn
% is the file's svn.keywords which is set to "Revision"
rev_info = 'SVN $Revision: 1495 $';
disp(sprintf('%s %s running',mfilename,rev_info))

if nargin < 1, help(mfilename), adcpFile=''; end
if nargin < 2, epDataFile=''; end
if nargin < 3, ADCPtype = ''; end
if nargin < 4, dlgFile=''; end

if isempty(adcpFile), adcpFile = '*'; end
if isempty(epDataFile), epDataFile = '*'; end
if isempty(ADCPtype), ADCPtype = 'WH'; end
if isempty(dlgFile), dlgFile = '*'; end

% Open ADCP beam file.
if any(adcpFile == '*')
    [theFile, thePath] = uigetfile(adcpFile, 'Select ADCP File:');
    if ~any(theFile), return, end
    if thePath(end) ~= filesep, thePath(end+1) = filesep; end
    adcpFile = [thePath theFile];
end

[path,name]=fileparts(adcpFile);
suggest=[name(1:end-1) '.nc'];
%create ADCP Geographic coordinates File
if any(epDataFile == '*')
    [theFile, thePath] = uiputfile(suggest, 'Save Data in geographic coordinates as:');
    if ~any(theFile), return, end
    if thePath(end) ~= filesep, thePath(end+1) = filesep; end
    epDataFile = [thePath theFile];
end
%
if ~exist(adcpFile,'file'), 
    disp(sprintf('%s: input file %s not found - aborting',mfilename,adcpFile))
    epDataFile = [];
    return, 
end
B = netcdf(adcpFile );
if isempty(B), return, end

%let's deal with the time
ppens=B.pings_per_ensemble(:);
tp=B.time_between_ping_groups(:);
%in order to ping as fast as possible tp may be set to 0,
%but in reality it is approximately 0.288 sec per ping.
if isequal(tp,0);
    tp = 0.288;
end

tens=ppens*tp;

allTIM=B{'TIM'}(:);
% calculate time step for output file, in seconds (FH 10 May 2000)
timsecs=B{'TIM'}(:)*24*3600;
delta=mean(diff(timsecs));
clear timsecs

gtD=gregorian(allTIM);
start_time = datestr(datenum(gtD(1,1),gtD(1,2),gtD(1,3),gtD(1,4),gtD(1,5),gtD(1,6)),0);
stop_time = datestr(datenum(gtD(end,1),gtD(end,2),gtD(end,3),gtD(end,4),gtD(end,5),gtD(end,6)),0);

% TODO - this is memory intensive, this could be done better
%Tim is the beginning of the ensemble, make it the middle
tsec=gtD(:,4)*3600 + gtD(:,5)*60 + gtD(:,6);
tmid=tsec+tens/2;
disp(['TIM was corrected by ' num2str(tens/2) ' sec = half the ensemble time']);
disp(' ')
sec=rem(tmid,60);
hmt=(tmid-sec)/60;
minu=rem(hmt,60);
hr=(hmt-minu)/60;
Mid_Ens_time=[gtD(:,1) gtD(:,2) gtD(:,3) hr minu sec];

disp('Converting "TIM" to "time" and "time2"');
m = size(Mid_Ens_time, 1);
alltime = (ones(m,2).*NaN);
for ii=1:m;
    alltime(ii,:)=ep_time(Mid_Ens_time(ii,:));
    if (ii<1000 && ~rem(ii,100)) || (ii>1000 && ~rem(ii,1000)),
        disp(sprintf('%d converted',ii)),
    end
end

Time=alltime(:,1);
Time2=alltime(:,2);

clear alltime

%get some information

theFillValue = fillval(B{'vel1'});
nbins = size(B('bin'),1);
ensemble = size(B('ensemble'),1);
transducer_off = B{'D'}.transducer_offset_from_bottom (:);
serial = B.ADCP_serial_number(:);
coord = B.transform(:);
orientation = B.orientation(:);
bin_size = B{'D'}.bin_size(:);
center_first_bin = B{'D'}.center_first_bin(:);

%Depth Calculation: (added 04-Apr-2003)
%   1.  Use pressure sensor if available
%   2.  Use values from Surface.exe calculated using Trimbins.m (only for upward looking)
%   3.  Use user input values calculated using Trimbins.m for upward looking or user input values asked for now for downward looking
% this water_depth gets changed by trimbins to MSL
% but it is possible for the user to bypass trimbins - add traps
% if trimbins is bypassed, then water_depth is from rdi2cdf, the user's input
wdepth = B{'D'}.water_depth(:); 
wdepth_source = B{'D'}.water_depth_source(:);
% first, see if trimbins was run - or we really know the source of water_depth
if isempty(wdepth) || (wdepth<=0) || isempty(wdepth_source) || ~isempty(findstr(wdepth_source, 'rdi2cdf')),
    % we need to double check
    disp(sprintf('%s: water depth was taken from %s', mfilename, wdepth_source))
    disp(sprintf('water_depth = %f, re-evaluating', wdepth))
    if ~isempty(B{'Pressure'}), % pressure data is present
        depth_head = gmean(B{'Pressure'}(:))/9806.65;   % depth at transducer head in meters
        wdepth = depth_head+transducer_off;
        wdepth_source = 'water depth = MSL from pressure sensor, by adcp2ep';
        %dnote = 'Depth values were calculated using the ADCP Pressure Sensor, assuming 9806.65 Pascals per meter.';       
    elseif ~isempty(B{'brange'}) && strcmp(orientation,'UP'), % pressure is preferable, but we can use ADCP range to surface
        depth_head = gmean(B{'brange'}(:));
        wdepth = depth_head+transducer_off;
        wdepth_source = 'water depth = MSL from acoustic range, by adcp2ep';
        %dnote = 'Depth values were calculated using acoustic range to surface.';
    else % we have nothing
        % TODO - this dialog box was preventing the command line from
        % updating and it loked like MATLAB was hung.  No fix known as
        % yet.
        %             prompt  = {'Enter the mean sea level value in meters:'};
        %             def     = {'0'};
        %             title   = 'User must input the nominal water depth information';
        %             lineNo  = 1;
        %             dlgresult  = inputdlg(prompt,title,lineNo,def);
        %             MSL = str2double(dlgresult{1});
        if isempty(wdepth), % if compute in trimbins, keep that value
            wdepth = input('Enter the mean sea level value in meters: ');
            disp(sprintf('User input value for depth: %f meters',wdepth))
            wdepth_source = 'water depth = MSL from user input by adcp2ep';
        end
        depth_head = wdepth - transducer_off;
        %dnote = 'Depth values were calculated using user input values';
    end %end if pressure/else
else
    depth_head = wdepth - transducer_off;
end
disp(wdepth_source)

% bindist is range to bin from head
disp(orientation)
disp(sprintf('Center_first_bin = %f',center_first_bin));
disp(sprintf('bin_size = %f',bin_size));
disp(sprintf('depth_head = %f',depth_head));
%bindist = center_first_bin:bin_size:((nbins+1)*bin_size);
bindist = (0:nbins-1).*bin_size+center_first_bin;
disp(sprintf('%d bin ranges for %d bins',length(bindist), nbins));

% now compute the bin depths
switch orientation
    case 'UP'
        depth = depth_head - bindist; 
        dnote = 'uplooking bin depths = ADCP depth - range to bin';
    case 'DOWN'
        depth = depth_head + bindist; 
        dnote = 'downlooking bin depths = ADCP depth + range to bin';
end 

% switch orientation
%     case 'UP'
%         % compute the depths of the bins relative tot he sea surface
%         depth = wdepth - B{'D'}(:); % D contains bin depths relative to the sea bed
%         dnote = 'uplooking bin depths = water_depth - bin distance to sea bed';
%     case 'DOWN'
%         bin1 = depth_head+center_first_bin;
%         binEnd = ((nbins-1)*bin_size)+bin1;
%         depth = (bin1:bin_size:binEnd)';
%         dnote = 'downlooking bin depths = ADCP depth + range to bin';
% end %end switch
disp(dnote)
disp(sprintf('Depths are from %6.2f at the head to %6.2f',depth(1),depth(end)))

disp(['The file has ' num2str(ensemble) ' ensembles and ' num2str(nbins) ' bins']);

disp(' ')
disp('Averaging echo intensity')
% Average echo intensity.
i1 = B{'AGC1'};
i1 = autonan(i1,1);
i2 = B{'AGC2'};
i2 = autonan(i2,1);
i3 = B{'AGC3'};
i3 = autonan(i3,1);
i4 = B{'AGC4'};
i4 = autonan(i4,1);
iall(:,:,1) = i1(:,:);
iall(:,:,2) = i2(:,:);
iall(:,:,3) = i3(:,:);
iall(:,:,4) = i4(:,:);
iavg = mean(iall,3);

%free up some memory
clear i1 i2 i3 i4 iall

disp(' ')
disp('Averaging percent good')

if strcmp(coord, 'BEAM')
    % Average percent good.
    p1 = B{'PGd1'};
    p1 = autonan(p1,1);
    p2 = B{'PGd2'};
    p2 = autonan(p2,1);
    p3 = B{'PGd3'};
    p3 = autonan(p3,1);
    p4 = B{'PGd4'};
    p4 = autonan(p4,1);
    pall(:,:,1) = p1(:,:);
    pall(:,:,2) = p2(:,:);
    pall(:,:,3) = p3(:,:);
    pall(:,:,4) = p4(:,:);
    pavg = mean(pall,3);
else % PGD has a different meaning for SHIP, INST and EARTH coordinates
    p4 = B{'PGd4'};
    p4 = autonan(p4,1);
    pavg = p4(:,:);
end

%free up some memory
clear p1 p2 p3 p4 pall


%check for fill values
TF = isnan(iavg);
MTF = max(max(TF));
if MTF
    fill_flag = 1;
end

TF = isnan(pavg);
MTF = max(max(TF));
if MTF
    fill_flag = 1;
end

%get the velocity data and set the new velocity variable
%dependent on being in Beam or Earth coordinates
disp(sprintf('Data is in %s coordinates',B.transform(:)))
switch coord
    case 'BEAM'
        disp('Data in Beam coordinates is being transformed to Earth')
        cur = runbm2g(adcpFile, ADCPtype, dlgFile);
        % close(B) % closed in runbm2geo
        bm2gcomment = sprintf('Transformed to earth coordinates by bm2geo;\n');
    otherwise
        vel = cell(4,1);
        for ii = 1:4;
            vel{ii} = B{['vel' int2str(ii)]};
        end
        %u = vel{1}(:);
        %v = vel{2}(:);
        % Change by MM 12-feb-2007 prevent double rotation of EARTH data
        % ignore heading bias settings, as these come from the EB command
        % changes by the ADCP or by wavesmon and have already been applied
        % to the heading and thus will be in the vectors already
        % if user supplied a user_applied_heading_correction
        % heading was rotated in rdi2cdf, but since the beam transformation
        % was performed by the ADCP, the vectors are not rotated.  Do it here.
        % this correction will usually be declination, but as this is written,
        % SHIP or INST coordinates can be adjusted by a heading alignment
        disp(sprintf('user_applied_heading_correction is %f', ...
            B{'Hdg'}.user_applied_heading_correction(:)))
        magnetic = B{'Hdg'}.user_applied_heading_correction(:);
        if ~isempty(magnetic),
            disp(sprintf('velocities are being rotated by %f', magnetic))
            % is the sign correct for West = negative correction sense?
            % this is correct - F. Lightsom 9-feb-2007
            theta = -1*magnetic;
            %[ur,vr] = uv_rotate(u,v,theta);
            [ur,vr] = uv_rotate(vel{1}(:),vel{2}(:),theta);
            %need to reset theFillValue
            urmax = max(max(ur));  vrmax = max(max(vr));
            ur(ur == urmax) = theFillValue;
            vr(vr == vrmax) = theFillValue;
            %fill in rotated velocity values
            [vel{1},vel{2}] = deal(ur,vr);
        end
        
        cur = cell(size(vel));
        for k=1:4, cur{k} = vel{k}; end
        %         cur = cell(size(vel));   % Output currents and error.
        %         p = zeros(4, bin);
        %         for ii=1:ensemble
        %             for k = 1:4
        %                 p(k, :) = vel{k}(ii, :);
        %                 cur{k}(ii, :) = p(k, :);
        %             end
        %             if ~rem(ii,100),
        %                 disp(sprintf('%d ensembles copied',ii)),
        %             end
        %         end
end

%scale as cm/sec
q = zeros(ensemble, nbins);
for k =1:4;
    q(:, :) = cur{k}(:, :);
    q(q == theFillValue) = nan;
    q = q./10;
    q(isnan(q)) = theFillValue;
    cur{k}(:,:) = q;
end

%Get the mins and maxes for later
minsc = zeros(4,1);
maxsc = minsc;
for k=1:4
    good_cur=(cur{k}(:,:) ~= theFillValue);
    scur=cur{k}(logical(good_cur));
    minsc(k) = gmin(gmin(scur));
    maxsc(k) = gmax(gmax(scur));
end
clear p q good_cur scur

% Check for fill values.

for k=1:4;
    TF = isnan(cur{k}(:,:));
    MTF =(gmax(gmax(TF)));
    if MTF
        fill_flag = 1;
    else
        fill_flag = 0;
    end
end


%**********************************************************************
% Create the new output file.
G = netcdf(epDataFile,'clobber');

%Global Attributes
%copy the globals from the Beam File
%figure out what needs to be deleted, changed, or added to the final files
%delete the following variables
disp('Modifying the global attributes');
A=att(B);
Anames=ncnames(A);
AN=length(Anames);

for nn=1:AN-1
    if isequal(Anames{AN-nn},'sensor_configuration');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'transducer_attached');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'simulated_data');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'beams_in_velocity_calculation');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'profiling_mode');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'code_repetitions');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'transmit_lag_distance');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'transform');
        A(AN-nn) = [];
        %added 12/15/04 (SDR)
    elseif isequal(Anames{AN-nn},'Sound_speed_computed_from_ED_ES_ET');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'ED_taken_from_depth_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'EH_taken_from_transducer_heading_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'EP_taken_from_transducer_pitch_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'ER_taken_from_transducer_roll_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'ES_derived_from_conductivity_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'ET_taken_from_temperature_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'depth_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'heading_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'pitch_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'roll_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'conductivity_sensor');
        A(AN-nn) = [];
    elseif isequal(Anames{AN-nn},'temperature_sensor');
        A(AN-nn) = [];
    end
end


mm=1;

while mm < AN-1
    notenum = ['NOTE_',int2str(mm)];
    Anames=ncnames(A);
    AN=length(Anames);
    for nn=1:AN-1
        if isequal(Anames{AN-nn},notenum);
            A(AN-nn) = [];
        end
    end
    mm=mm+1;
end

%put the ones that are left into new file (G)
% mlint doesn't like this line.  Don't touch it.
G < A;

%change and add the following attributes and variables
G.CREATION_DATE = datestr(now,0);
G.initial_instrument_height = B{'D'}.transducer_offset_from_bottom(1);
G.initial_instrument_height_note = 'height in meters above bottom: accurate for tripod mounted instruments';
G.nominal_sensor_depth = wdepth - B{'D'}.transducer_offset_from_bottom(1);
G.nominal_sensor_depth_note = 'inst_depth = (water_depth - inst_height); nominal depth below surface';

%RENAME A FEW
moor = G.Mooring_number;
rename(moor,'MOORING');
pulse = G.transmit_pulse_length;
rename(pulse,'transmit_pulse_length_cm');

%Define some new ones for Epic compatability - these are already known
% these dont' change
G.transform = 'EARTH';
G.DATA_TYPE = 'ADCP';
G.DATA_SUB_TYPE = 'MOORED';
G.COORD_SYSTEM = 'GEOGRAPHIC';
G.WATER_MASS = ncchar('?');
G.POS_CONST = nclong(0);  %1 if consistent
G.DEPTH_CONST = nclong(0);  %1 if consistent
G.WATER_DEPTH = wdepth; % water depth computed from surace detect or pressure sensor
G.DRIFTER = nclong(0);

% these we ahve already determined
G.WATER_DEPTH_SOURCE = wdepth_source;
G.VAR_FILL = theFillValue;

% now get the rest of the attributes that vary with experiment/site
% fields and def must have the same length and values must line up
fields = {'experiment', 'descript', 'project', 'cmnt',...
    'long', 'lonUnits', 'latit', 'latUnits', ...
    'origin', 'scipi', 'convention'};
def = {'','','','none',...
    '','degree_east','','degree_north',...
    '','','EPIC/PMEL'};
if exist('settings','var')
    % deal out the settings
    for ifield = 1:length(fields),
        if isfield(settings,fields{ifield}),
            eval(sprintf('%s = settings.%s;',fields{ifield},fields{ifield}))
        else eval(sprintf('%s = '''';',fields{ifield}))
        end
    end
else
    title   = ['Data Collection Information: ',G.MOORING(:)];
    lineNo  = 1;
    dlgresult  = inputdlg(fields,title,lineNo,def,'on'); 
    for ifield = 1:length(fields),
        eval(sprintf('%s = dlgresult{ifield};',fields{ifield}))
    end

    % some special treatment
    if isempty(lonUnits), lonUnits = 'not specified'; end
    if isempty(latUnits), latUnits = 'not specified'; end
    if isempty(long), long = theFillValue; 
    else long = str2double(long); end
    if isempty(latit), latit = theFillValue; 
    else latit = str2double(latit); end
end

G.DATA_ORIGIN = origin;
G.Conventions = convention;
G.EXPERIMENT =experiment;
G.PROJECT = project;
G.DESCRIPT = descript;
G.longitude = long;
G.latitude = latit;
G.DATA_CMNT = cmnt;
G.SciPi = scipi;

%Need to calculate or derive the following
G.FILL_FLAG=nclong(fill_flag);
G.COMPOSITE=nclong(0);
% this is added at the very end by add_vardesc.m
%G.VAR_DESC='u:v:w:Werr:AGC:PGd:Tx';

%calculate dt** this section removed FH 10 May 2000
%tim=B{'TIM'};
%gt=gregorian(tim(:));
%dt=diff(gt);
%delta=(dt(1,4).*60)+(dt(1,5))+(dt(1,6)./60);

G.DELTA_T=ncchar(num2str(delta));
G.start_time = start_time;
G.stop_time = stop_time;

magnetic = B{'Hdg'}.heading_bias(:); % information should be stored with Hdg
if isempty(magnetic)
    magnetic = B.heading_bias(:);
end
G.magnetic_variation = magnetic;

%define the dimensions
G('time') = 0;
%G('depth') = length(B{'D'});
G('depth') = length(depth);
G('lon') = 1;
G('lat') = 1;


%Variables and Attributes
disp('Defining variables and their attributes')
disp('...Defining "time"')

G{'time'} = nclong('time');
G{'time'}.FORTRAN_format = ncchar('F10.2');
G{'time'}.units = ncchar('True Julian Day');
G{'time'}.type = ncchar('UNEVEN');
G{'time'}.epic_code = nclong(624);
%G{'time'}.FillValue_ = theFillValue;


disp('...Defining "time2"')
G{'time2'} = nclong('time') ;
G{'time2'}.FORTRAN_format = ncchar('F10.2');
G{'time2'}.units = ncchar('msec since 0:00 GMT');
G{'time2'}.type = ncchar('UNEVEN');
G{'time2'}.epic_code = nclong(624);
%G{'time2'}.FillValue_ = theFillValue;


disp('...Defining "depth"')
G{'depth'} = ncfloat('depth');
G{'depth'}.FORTRAN_format = ncchar('F10.2');
G{'depth'}.units = ncchar('m');
G{'depth'}.type = ncchar('EVEN');
G{'depth'}.epic_code = nclong(3);
G{'depth'}.long_name = ncchar('DEPTH (m)');
G{'depth'}.blanking_distance = B{'D'}.blanking_distance(:);
G{'depth'}.bin_size = B{'D'}.bin_size(:);
G{'depth'}.center_first_bin = B{'D'}.center_first_bin(:);
G{'depth'}.transducer_offset_from_bottom = B{'D'}.transducer_offset_from_bottom(:);
%G{'depth'}.FillValue_ = theFillValue;
G{'depth'}.NOTE = ncchar(dnote);

disp('...Defining "bindist"')
G{'bindist'} = ncfloat('depth');
ncobj = G{'bindist'};
ncobj.FORTRAN_format = ncchar('f10.2');
ncobj.units = ncchar('m');
ncobj.type = ncchar('EVEN');
ncobj.epic_code = nclong(0);
ncobj.long_name = ncchar('bin distance from ADCP (m)');
ncobj.name = ncchar('bindist');
ncobj.generic_name = ncchar('bindist');
ncobj.bin_size = B{'D'}.bin_size(:);
ncobj.transducer_offset_from_bottom = B{'D'}.transducer_offset_from_bottom(:);
ncobj.center_first_bin = B{'D'}.center_first_bin(:);
ncobj.blanking_distance = B{'D'}.blanking_distance(:);
ncobj.sensor_depth = wdepth - transducer_off;
ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
ncobj.FillValue_ = theFillValue;
ncobj.NOTE = ncchar('distance is along profile from ADCP head to center of bin');

disp('...Defining "lon"')
G{'lon'} = ncfloat('lon'); %% 1 element.
G{'lon'}.FORTRAN_format = ncchar('f10.4');
G{'lon'}.units = ncchar(lonUnits);
G{'lon'}.type = ncchar('EVEN');
G{'lon'}.epic_code = nclong(502);
G{'lon'}.name = ncchar('LON');
G{'lon'}.long_name = ncchar('LONGITUDE');
G{'lon'}.generic_name = ncchar('lon');
%G{'lon'}.FillValue_ = theFillValue;

disp('...Defining "lat"')
G{'lat'} = ncfloat('lat'); %% 1 element.
G{'lat'}.FORTRAN_format = ncchar('F10.2');
G{'lat'}.units = ncchar(latUnits);
G{'lat'}.type = ncchar('EVEN');
G{'lat'}.epic_code = nclong(500);
G{'lat'}.name = ncchar('LAT');
G{'lat'}.long_name = ncchar('LATITUDE');
G{'lat'}.generic_name = ncchar('lat');
%G{'lat'}.FillValue_ = theFillValue;

disp('...Defining "u_1205"')
G{'u_1205'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'u_1205'}.name = ncchar('u');
G{'u_1205'}.long_name = ncchar('Eastward Velocity');
G{'u_1205'}.generic_name = ncchar('u');
G{'u_1205'}.FORTRAN_format = ncchar(' ');
G{'u_1205'}.units = ncchar('cm/s');
G{'u_1205'}.epic_code = nclong(1205);
G{'u_1205'}.sensor_type = B.INST_TYPE(:);
G{'u_1205'}.sensor_depth = wdepth - transducer_off;
G{'u_1205'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'u_1205'}.serial_number = nclong(serial);
G{'u_1205'}.minimum = ncfloat(minsc(1));
G{'u_1205'}.maximum = ncfloat(maxsc(1));
%Not sure this is the right valid range, but what Fran had
G{'u_1205'}.valid_range = ncfloat([-1000 1000]);
G{'u_1205'}.FillValue_ = theFillValue;

disp('...Defining "v_1206"')
G{'v_1206'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'v_1206'}.name = ncchar('v');
G{'v_1206'}.long_name = ncchar('Northward Velocity');
G{'v_1206'}.generic_name = ncchar('v');
G{'v_1206'}.FORTRAN_format = ncchar(' ');
G{'v_1206'}.units = ncchar('cm/s');
G{'v_1206'}.epic_code = nclong(1206);
G{'v_1206'}.sensor_type = B.INST_TYPE(:);
G{'v_1206'}.sensor_depth = wdepth - transducer_off;
G{'v_1206'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'v_1206'}.serial_number = nclong(serial);
G{'v_1206'}.minimum = ncfloat(minsc(2));
G{'v_1206'}.maximum = ncfloat(maxsc(2));
G{'v_1206'}.valid_range = ncfloat([-1000 1000]);
G{'v_1206'}.FillValue_ = theFillValue;

disp('...Defining "w_1204"')
G{'w_1204'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'w_1204'}.name = ncchar('w');
G{'w_1204'}.long_name = ncchar('Vertical Velocity');
G{'w_1204'}.generic_name = ncchar('w');
G{'w_1204'}.FORTRAN_format = ncchar(' ');
G{'w_1204'}.units = ncchar('cm/s');
G{'w_1204'}.epic_code = nclong(1204);
G{'w_1204'}.sensor_type = B.INST_TYPE(:);
G{'w_1204'}.sensor_depth = wdepth - transducer_off;
G{'w_1204'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'w_1204'}.serial_number = nclong(serial);
G{'w_1204'}.minimum = ncfloat(minsc(3));
G{'w_1204'}.maximum = ncfloat(maxsc(3));
G{'w_1204'}.valid_range = ncfloat([-1000 1000]);
G{'w_1204'}.FillValue_ = theFillValue;

disp('...Defining "Werr_1201"')
G{'Werr_1201'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'Werr_1201'}.name = ncchar('Werr');
G{'Werr_1201'}.long_name = ncchar('Error Velocity');
G{'Werr_1201'}.generic_name = ncchar('w');
G{'Werr_1201'}.FORTRAN_format = ncchar('F8.1');
G{'Werr_1201'}.units = ncchar('cm/s');
G{'Werr_1201'}.epic_code = nclong(1201);
G{'Werr_1201'}.sensor_type = B.INST_TYPE(:);
G{'Werr_1201'}.sensor_depth = wdepth - transducer_off;
G{'Werr_1201'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'Werr_1201'}.serial_number = nclong(serial);
G{'Werr_1201'}.minimum = ncfloat(minsc(4));
G{'Werr_1201'}.maximum = ncfloat(maxsc(4));
G{'Werr_1201'}.valid_range = B.error_velocity_threshold(:);
G{'Werr_1201'}.FillValue_ = theFillValue;

disp('...Defining "AGC_1202"')
G{'AGC_1202'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'AGC_1202'}.name = ncchar('AGC');
G{'AGC_1202'}.long_name = ncchar('Average Echo Intensity (AGC)');
G{'AGC_1202'}.generic_name = ncchar('AGC');
G{'AGC_1202'}.FORTRAN_format = ncchar('F5.1');
G{'AGC_1202'}.units = ncchar('counts');
G{'AGC_1202'}.epic_code = nclong(1202);
G{'AGC_1202'}.sensor_type = B.INST_TYPE(:);
G{'AGC_1202'}.sensor_depth = wdepth - transducer_off;
G{'AGC_1202'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'AGC_1202'}.serial_number = nclong(serial);
G{'AGC_1202'}.norm_factor = B{'AGC1'}.norm_factor(:);
G{'AGC_1202'}.NOTE = ncchar('normalization to db');
G{'AGC_1202'}.minimum = ncfloat(min(min(iavg)));
G{'AGC_1202'}.maximum = ncfloat(max(max(iavg)));
G{'AGC_1202'}.valid_range = B.false_target_reject_values(:);
G{'AGC_1202'}.FillValue_ = theFillValue;

disp('...Defining "PGd_1203"')
G{'PGd_1203'} = ncfloat('time', 'depth', 'lat', 'lon');
G{'PGd_1203'}.name = ncchar('PGd');
G{'PGd_1203'}.long_name = ncchar('Percent Good Pings');
G{'PGd_1203'}.generic_name = ncchar('PGd');
G{'PGd_1203'}.FORTRAN_format = ncchar(' ');
G{'PGd_1203'}.units = ncchar('counts');
G{'PGd_1203'}.epic_code = nclong(1203);
G{'PGd_1203'}.sensor_type = B.INST_TYPE(:);
G{'PGd_1203'}.sensor_depth = wdepth - transducer_off;
G{'PGd_1203'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'PGd_1203'}.serial_number = nclong(serial);
G{'PGd_1203'}.minimum = ncfloat(min(min(pavg)));
G{'PGd_1203'}.maximum = ncfloat(max(max(pavg)));
G{'PGd_1203'}.valid_range = B.minmax_percent_good(:);
G{'PGd_1203'}.FillValue_ = theFillValue;

if ~isempty(B{'brange'}(:)),
    disp('...Defining "brange"')
    G{'brange'} = ncfloat('time', 'lat', 'lon');
    ncobj = G{'brange'};
    ncobj.name = ncchar('brange');
    ncobj.long_name = ncchar('range from ADCP head to boundary');
    ncobj.generic_name = ncchar('brange');
    ncobj.FORTRAN_format = ncchar('f10.2');
    ncobj.units = ncchar('m');
    ncobj.epic_code = nclong(0);
    ncobj.sensor_depth = wdepth - transducer_off;
    ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
    ncobj.minimum = ncfloat(0);
    ncobj.maximum = ncfloat(0);
    ncobj.serial_number = nclong(serial);
    switch B.frequency(1), % this is more realistic
        case 1200
            ncobj.valid_range = ncfloat([0 50]);
        case 600
            ncobj.valid_range = ncfloat([0 100]);
        case 300
            ncobj.valid_range = ncfloat([0 200]);
        otherwise
            ncobj.valid_range = ncfloat([0 1000]);
    end
    ncobj.FillValue_ = theFillValue;
    ncobj.NOTE = B{'brange'}.NOTE(:);
else
    disp('No range to boundary data, skipping brange')
end

% 1211:Tx  :ADCP Transducer Temp.    :temp:deg. C:F10.2:ADCP Transducer Temp
disp('...Defining "Tx_1211"')
G{'Tx_1211'} = ncfloat('time', 'lat', 'lon');
G{'Tx_1211'}.name = ncchar('Tx');
G{'Tx_1211'}.long_name = ncchar('ADCP Transducer Temp.');
G{'Tx_1211'}.generic_name = ncchar('temp');
G{'Tx_1211'}.units = ncchar('degrees.C');
G{'Tx_1211'}.epic_code = nclong(1211);
G{'Tx_1211'}.sensor_type = B.INST_TYPE(:);
G{'Tx_1211'}.sensor_depth = wdepth - transducer_off;
G{'Tx_1211'}.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
G{'Tx_1211'}.serial_number = nclong(serial);
G{'Tx_1211'}.minimum = ncfloat(0);
G{'Tx_1211'}.maximum = ncfloat(0);
G{'Tx_1211'}.valid_range = B{'Tx'}.valid_range(:);
G{'Tx_1211'}.FillValue_ = theFillValue;

disp('...Defining "Hdg_1215"')
% 1215:Hdg :INST Heading             :hdg:degrees:F10.2:ADCP heading
G{'Hdg_1215'} = ncfloat('time','lat', 'lon');
ncobj = G{'Hdg_1215'};
ncobj.name = ncchar('Hdg');
ncobj.long_name = ncchar('INST Heading             ');
ncobj.generic_name = ncchar('hdg');
ncobj.epic_code = nclong(1215);
ncobj.units = ncchar('degrees');
ncobj.FORTRAN_format = ncchar('f10.2');
ncobj.sensor_type = B.INST_TYPE(:);
ncobj.sensor_depth = wdepth - transducer_off;
ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
ncobj.serial = nclong(serial);
ncobj.minimum = ncfloat(0);
ncobj.maximum = ncfloat(0);
ncobj.valid_range = ncfloat([0 360]);
ncobj.FillValue_ = theFillValue;

disp('...Defining "Ptch_1216"')
% 1216:Ptch:INST Pitch               :ptch:degrees:F10.2:ADCP pitch
G{'Ptch_1216'} = ncfloat('time','lat', 'lon');
ncobj = G{'Ptch_1216'};
ncobj.name = ncchar('Ptch');
ncobj.long_name = ncchar('INST Pitch             ');
ncobj.generic_name = ncchar('ptch');
ncobj.epic_code = nclong(1216);
ncobj.units = ncchar('degrees');
ncobj.FORTRAN_format = ncchar('f10.2');
ncobj.sensor_type = B.INST_TYPE(:);
ncobj.sensor_depth = wdepth - transducer_off;
ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
ncobj.serial = nclong(serial);
ncobj.minimum = ncfloat(0);
ncobj.maximum = ncfloat(0);
ncobj.valid_range = ncfloat([-180 180]);
ncobj.FillValue_ = theFillValue;

disp('...Defining "Ptch_1216"')
% 1217:Roll:INST Roll                :roll:degrees:F10.2:ADCP roll
G{'Roll_1217'} = ncfloat('time','lat', 'lon');
ncobj = G{'Roll_1217'};
ncobj.name = ncchar('Roll');
ncobj.long_name = ncchar('INST Roll             ');
ncobj.generic_name = ncchar('roll');
ncobj.epic_code = nclong(1217);
ncobj.units = ncchar('degrees');
ncobj.FORTRAN_format = ncchar('f10.2');
ncobj.sensor_type = B.INST_TYPE(:);
ncobj.sensor_depth = wdepth - transducer_off;
ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
ncobj.serial = nclong(serial);
ncobj.minimum = ncfloat(0);
ncobj.maximum = ncfloat(0);
ncobj.valid_range = ncfloat([-180 180]);
ncobj.FillValue_ = theFillValue;

% 1294:P:ADCP Pressure:pres:deca-pascals:F15.2:ADCP Pressure at Transducer Head
if ~isempty(B{'Pressure'}),
    disp('...Defining "P_1294"')
    G{'P_1294'} = ncfloat('time', 'lat', 'lon');
    ncobj = G{'P_1294'};
    ncobj.name = ncchar('P');
    ncobj.long_name = ncchar('ADCP Pressure at Transducer Head');
    ncobj.generic_name = ncchar('pres');
    ncobj.units = ncchar('deca-pascals');
    ncobj.FORTRAN_format = ncchar('f15.2');
    ncobj.epic_code = nclong(1294);
    ncobj.sensor_type = B.INST_TYPE(:);
    ncobj.sensor_depth = wdepth - transducer_off;
    ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
    ncobj.serial_number = nclong(serial);
    ncobj.minimum = ncfloat(0);
    ncobj.maximum = ncfloat(0);
    ncobj.valid_range = B{'Pressure'}.valid_range(:);
    ncobj.FillValue_ = theFillValue;
    ncobj.NOTE = ncchar('Pressure is atmospheric, no adjustment made for atmospheric pressure');
else
    disp('No pressure data...skipping "P_1294"')
end

% 850:SDP:STAND. DEV. (PRESS)     :pres:mbar:f10.5:std. deviation of burst pressures
if ~isempty(B{'PressVar'}),
    disp('...Defining "SDP_850"')
    % 850:SDP:STAND. DEV. (PRESS)     :pres:mbar:f10.5:std. deviation of burst pressures
    G{'SDP_850'} = ncfloat('time','lat', 'lon');  
    ncobj = G{'SDP_850'};
    ncobj.epic_code = nclong(850);
    ncobj.name = ncchar('SDP');
    ncobj.long_name = ncchar('STAND. DEV. (PRESS)     ');
    ncobj.generic_name = ncchar('pres');
    ncobj.units = ncchar('mbar');
    ncobj.sensor_type = B.INST_TYPE(:);
    ncobj.sensor_depth = wdepth - transducer_off;
    ncobj.initial_sensor_height = B{'D'}.transducer_offset_from_bottom (:);
    ncobj.serial_number = nclong(serial);
    ncobj.minimum = ncfloat(0);
    ncobj.maximum = ncfloat(0);
    ncobj.valid_range = ncfloat([0 5000]);
    ncobj.FillValue_ = theFillValue;
end

endef(G)


%Put in the Data
m=ensemble;
disp(sprintf('m = ensemble = %f',m))

disp(['Copying data to ' epDataFile]);
disp('... time')
G{'time'}(1:m)= Time;
disp('... time2')
G{'time2'}(1:m) = Time2;
disp('... lat')
if ischar(G.latitude(:)),
    G{'lat'}(1) = str2double(G.latitude(:));
else
    G{'lat'}(1) = G.latitude(:);
end
disp('... lon')
if ischar(G.longitude(:)),
    G{'lon'}(1) = str2double(G.longitude(:));
else
    G{'lon'}(1) = G.longitude(:);
end
disp('... depth')
G{'depth'}(1:nbins) = depth;
disp('... bindist')
G{'bindist'}(1:nbins) = bindist;
disp('... u_1205')
G{'u_1205'}(1:m, 1:nbins, 1, 1) = cur{1}(:,:);
disp('... v_1206')
G{'v_1206'}(1:m, 1:nbins, 1, 1) = cur{2}(:,:);
disp('... w_1204')
G{'w_1204'}(1:m, 1:nbins, 1, 1) = cur{3}(:,:);
disp('... Werr_1201')
G{'Werr_1201'}(1:m, 1:nbins, 1, 1) = cur{4}(:,:);
disp('... AGC_1202')
G{'AGC_1202'}(1:m, 1:nbins, 1, 1) = iavg;
disp('... PGd_1203')
G{'PGd_1203'}(1:m, 1:nbins, 1, 1) = pavg;
if ~isempty(B{'brange'}(:)),
    disp('... brange')
    G{'brange'}(1:m, 1, 1) = B{'brange'}(:);
end
disp('... Tx_1211')
G{'Tx_1211'}(1:m, 1, 1) = B{'Tx'}(:);
disp('... Hdg_1215')
G{'Hdg_1215'}(1:m, 1, 1) = B{'Hdg'}(:);
disp('... Ptch_1216')
G{'Ptch_1216'}(1:m, 1, 1) = B{'Ptch'}(:);
disp('... Roll_1217')
G{'Roll_1217'}(1:m, 1, 1) = B{'Roll'}(:);
if ~isempty(B{'Pressure'}),
    disp('... P_1294')
    % for P_1294 need to convert pascals back to deca-pascals
    G{'P_1294'}(:, 1, 1) = B{'Pressure'}(:)./10;
end
if ~isempty(B{'PressVar'}),
    disp('... SDP_850')
    G{'SDP_850'}(1:m, 1, 1) = B{'PressVar'}(:);
end

% add minimums and maximums
add_minmaxvalues(G);
% add the variable description string
add_vardesc(G);

% check the local declination, even though it was set earlier
% do this at the end because it's a dialog box.
% this works for data with waves, because heading_bias comes from
% the EB command and thus gets passed on here.  But for non-waves data, no
% EB setting, this is an issue.
% there are two sources of information for the magnetic variation
% so the user is going to be asked at the end of the run 
magnetic_variation_source = 'None';
disp('Checking the magnetic variation settings to be sure...')
user_correction = B{'Hdg'}.user_applied_heading_correction(:); % user setting from settings.rdi2cdf.magnetic
disp(sprintf('User value of settings.rdi2cdf.magnetic recorded in Hdg.user_applied_heading_correction: %f',user_correction));
heading_bias = B{'Hdg'}.heading_bias(:); % EB setting, convert to degrees
disp(sprintf('ADCP heading bias setting (EB) recorded in Hdg.heading_bias: %f',heading_bias));
if (user_correction ~= 0) && (heading_bias ~= 0),
    % ask the user which is the correct magnetic variation
    str = {sprintf('%f: ADCP heading bias setting (EB)',heading_bias),...
        sprintf('%f: User value of settings.rdi2cdf.magnetic',user_correction),...
        'Enter a new value'};
    [selection,ok] = listdlg('PromptString',...
        'Which value is the correct local declination?',...
        'SelectionMode','single', 'ListString',str);
    if ok,
        if findstr(str{selection},'(EB)'),
            magnetic = heading_bias;
            magnetic_variation_source = 'heading bias set in instrument';
        elseif findstr(str{selection},'settings.rdi2cdf.magnetic'),
            magnetic = user_correction;
            magnetic_variation_source = 'user correction';
        elseif findstr(str{selection},'new value'),
            prompt  = {'Enter the local declination value in degrees, west is negative:'};
            def     = {'0'};
            title   = 'User input a new local declination';
            lineNo  = 1;
            dlgresult  = inputdlg(prompt,title,lineNo,def);
            magnetic = str2double(dlgresult{1});
            disp(sprintf('%s of %f',title,magnetic));
            magnetic_variation_source = 'user input after all data processed';
        end
    else
        disp('User did not clarify local declination value');
        magnetic_variation_source = 'unknown';
    end 
elseif (user_correction ~= 0),
    magnetic = user_correction;
    magnetic_variation_source = 'user correction';
elseif (heading_bias ~= 0),
    magnetic = heading_bias;
    magnetic_variation_source = 'heading bias set in instrument';
end
G.magnetic_variation = magnetic;
G.magnetic_variation_source = magnetic_variation_source;

close(B)
close(G)

if exist('bm2gcomment','var'),
    thecomment = sprintf('%s\n Written to an EPIC standard data file by %s %s; \n',...
        bm2gcomment, mfilename, rev_info);
else
    thecomment = sprintf('Written to an EPIC standard data file by %s %s; \n',...
        mfilename, rev_info);
end
history(epDataFile,thecomment);
